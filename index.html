<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>Crane Ops — CAD Lift Planner (Top + Side)</title>
  <style>
    :root{
      --bg:#070a0f;                 /* AutoCAD-ish modelspace vibe */
      --cad:#0b1220;
      --panel:#0f1621cc;
      --panel2:#0f1621f2;
      --ink:#e9eef7;
      --mut:#9fb0c7;
      --ok:#43f59a;
      --warn:#ffd166;
      --bad:#ff4d6d;
      --line:#2a3a52;
      --grid:#142238;
      --cadCyan:#33f6ff;
      --cadYellow:#ffd166;
      --cadMag:#ff74d4;
      --cadGreen:#43f59a;
      --cadRed:#ff4d6d;
      --shadow: 0 10px 35px rgba(0,0,0,.45);
      --r:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:var(--sans);overflow:hidden}

    .wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
    header{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:10px 12px;background:linear-gradient(180deg, rgba(15,22,33,.92), rgba(15,22,33,.55));
      border-bottom:1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(10px);
    }
    .brand{display:flex;align-items:center;gap:10px}
    .logo{
      width:30px;height:30px;border-radius:10px;background:
        radial-gradient(12px 12px at 30% 30%, rgba(67,245,154,.9), rgba(67,245,154,0) 60%),
        radial-gradient(16px 16px at 70% 70%, rgba(79,168,255,.9), rgba(79,168,255,0) 60%),
        linear-gradient(135deg, rgba(255,255,255,.12), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      border:1px solid rgba(255,255,255,.08);
    }
    .title{display:flex;flex-direction:column;line-height:1.05}
    .title b{font-size:14px;letter-spacing:.3px}
    .title span{font-size:12px;color:var(--mut)}
    .topBtns{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
    .btn{
      padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10); color:var(--ink);
      box-shadow: 0 8px 20px rgba(0,0,0,.22);
      cursor:pointer; user-select:none; -webkit-tap-highlight-color: transparent;
    }
    .btn:hover{background:rgba(255,255,255,.085)}
    .btn.primary{background:rgba(67,245,154,.14);border-color:rgba(67,245,154,.25)}
    .btn.bad{background:rgba(255,77,109,.12);border-color:rgba(255,77,109,.25)}
    .btn.small{padding:6px 9px;border-radius:10px;font-size:12px}
    .btn:active{transform:translateY(1px)}
    .btn:disabled{opacity:.55;cursor:not-allowed}

    main{position:relative}
    canvas{position:absolute;inset:0;width:100%;height:100%}

    .hud{
      position:absolute;left:12px;top:12px;display:flex;flex-direction:column;gap:10px;
      max-width:min(460px, calc(100% - 24px));
      pointer-events:none;
    }
    .card{
      pointer-events:none;
      background:var(--panel);
      border:1px solid rgba(255,255,255,.08);
      border-radius:var(--r);
      padding:10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between}
    .row .k{color:var(--mut);font-size:12px}
    .row .v{font-family:var(--mono);font-size:12px}
    .bars{display:grid;gap:6px;margin-top:8px}
    .bar{height:8px;border-radius:999px;background:rgba(255,255,255,.07);overflow:hidden;border:1px solid rgba(255,255,255,.06)}
    .bar > i{display:block;height:100%;width:50%;background:linear-gradient(90deg, rgba(79,168,255,.9), rgba(67,245,154,.9))}
    .bar.warn > i{background:linear-gradient(90deg, rgba(255,209,102,.95), rgba(255,77,109,.9))}
    .pills{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      border-radius:999px;padding:6px 10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      font-size:12px;color:rgba(233,238,247,.92);
      pointer-events:none;
    }
    .hint{
      position:absolute;left:50%;transform:translateX(-50%);
      bottom:12px;max-width:min(980px, calc(100% - 24px));
      background:rgba(15,22,33,.72);border:1px solid rgba(255,255,255,.09);
      border-radius:999px;padding:10px 14px;
      color:rgba(233,238,247,.92);
      box-shadow: var(--shadow); backdrop-filter: blur(10px);
      font-size:13px; text-align:center; pointer-events:none;
    }

    .overlay{ position:absolute;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,.55);backdrop-filter: blur(10px);padding:14px; }
    .overlay.on{display:flex}
    .panel{
      width:min(1100px, 100%);
      max-height:min(92vh, 820px);
      overflow:auto;
      background:var(--panel2);
      border:1px solid rgba(255,255,255,.10);
      border-radius:22px;
      box-shadow: 0 18px 80px rgba(0,0,0,.65);
      padding:14px;
    }
    .panelHead{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:6px 6px 10px;position:sticky;top:0;background:linear-gradient(180deg, rgba(15,22,33,.95), rgba(15,22,33,.84));backdrop-filter: blur(10px);border-bottom:1px solid rgba(255,255,255,.06);border-radius:18px}
    .panelHead h2{margin:0;font-size:16px;letter-spacing:.2px}
    .sub{color:var(--mut);font-size:12px;margin-top:2px}
    .grid{display:grid;grid-template-columns: repeat( auto-fit, minmax(250px, 1fr) );gap:10px;padding:10px 4px 6px}
    .tile{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.09);
      border-radius:18px;
      padding:12px;
      display:flex;flex-direction:column;gap:10px;
    }
    .tile.locked{opacity:.55;filter:saturate(.8)}
    .tileTop{display:flex;align-items:flex-start;justify-content:space-between;gap:8px}
    .tag{
      font-size:11px;color:rgba(233,238,247,.9);
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      padding:4px 8px;border-radius:999px;
    }
    .tag.ok{border-color:rgba(67,245,154,.25);background:rgba(67,245,154,.10)}
    .tag.bad{border-color:rgba(255,77,109,.25);background:rgba(255,77,109,.10)}
    .mini{color:var(--mut);font-size:12px;line-height:1.25}
    .stats{display:grid;gap:8px}
    .statline{display:flex;align-items:center;justify-content:space-between;gap:10px;font-size:12px}
    .statline span{color:var(--mut)}

    .tileBtns{display:flex;gap:8px;flex-wrap:wrap}

    .editorBar{
      display:flex;gap:8px;flex-wrap:wrap;align-items:center;
      padding:10px;border:1px solid rgba(255,255,255,.10);
      border-radius:18px;background:rgba(255,255,255,.04);
      margin:10px 4px;
    }
    .field{display:grid;gap:6px;margin-top:8px}
    .field label{font-size:12px;color:var(--mut)}
    .field input,.field select,.field textarea{
      width:100%;padding:10px 10px;border-radius:14px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      color:var(--ink);
      outline:none;
    }
    .field textarea{min-height:130px;font-family:var(--mono);font-size:12px}
    .kbd{font-family:var(--mono);font-size:12px;color:rgba(233,238,247,.85);background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);padding:3px 8px;border-radius:999px}

    /* Touch controls */
    .touchUI{position:absolute;inset:0;display:none;pointer-events:none;}
    .touchUI.on{display:block}
    .touchPad{
      position:absolute;bottom:12px;left:12px;
      width:min(42vw, 230px);height:min(42vw, 230px);
      border-radius:24px;
      background:rgba(15,22,33,.62);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      pointer-events:auto;
      touch-action:none;
      overflow:hidden;
    }
    .joyBase{position:absolute;inset:12px;border-radius:18px;border:1px dashed rgba(255,255,255,.12);
      background: radial-gradient(circle at 50% 30%, rgba(255,255,255,.06), rgba(255,255,255,0) 60%);}
    .joyKnob{
      position:absolute;left:50%;top:50%;
      width:66px;height:66px;margin-left:-33px;margin-top:-33px;border-radius:18px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
    }
    .touchRight{
      position:absolute;bottom:12px;right:12px;
      width:min(44vw, 250px);
      display:grid;gap:10px;pointer-events:auto;touch-action:none;
    }
    .hoist{
      height:min(42vw, 230px);
      border-radius:24px;
      background:rgba(15,22,33,.62);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      position:relative;overflow:hidden;
    }
    .hoist .track{position:absolute;inset:14px;border-radius:18px;border:1px dashed rgba(255,255,255,.12)}
    .hoist .fill{position:absolute;left:0;right:0;bottom:0;height:50%;background:linear-gradient(180deg, rgba(79,168,255,.0), rgba(79,168,255,.22))}
    .hoist .thumb{
      position:absolute;left:14px;right:14px;height:54px;border-radius:16px;
      background:rgba(255,255,255,.11);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
      top:calc(50% - 27px);
    }
    .touchBtns{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;}
    .tbtn{
      pointer-events:auto;border-radius:18px;padding:14px 10px;
      background:rgba(15,22,33,.62);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      text-align:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      font-weight:800;letter-spacing:.2px;
    }
    .tbtn small{display:block;color:var(--mut);font-size:11px;font-weight:600;margin-top:2px}
    .tbtn:active{transform:translateY(1px)}
    .tbtn.on{border-color:rgba(67,245,154,.28);background:rgba(67,245,154,.10)}
    .tbtn.dim{opacity:.35}

    @media (max-aspect-ratio: 9/16){
      header{padding:8px 10px}
      .hud{top:54px}
      .touchPad{width:min(46vw, 220px);height:min(46vw, 220px)}
      .touchRight{width:min(48vw, 260px)}
      .hoist{height:min(46vw, 220px)}
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="logo"></div>
      <div class="title">
        <b>Crane Ops <span style="opacity:.65">CAD Lift Planner</span></b>
        <span id="subtitle">Top (Plan) + Side (Elevation) • planning-gated gameplay</span>
      </div>
    </div>
    <div class="topBtns">
      <button class="btn small" id="btnHangar">Hangar</button>
      <button class="btn small" id="btnLevels">Levels</button>
      <button class="btn small" id="btnPlan">Plan</button>
      <button class="btn small" id="btnStandards">BS/EN</button>
      <button class="btn small" id="btnControls">Controls</button>
      <button class="btn small" id="btnSettings">Settings</button>
      <button class="btn small bad" id="btnRestart">Restart</button>
      <button class="btn small primary" id="btnPlay">Operate</button>
    </div>
  </header>

  <main>
    <canvas id="c"></canvas>

    <div class="hud">
      <div class="card">
        <div class="row"><div class="k">Crane</div><div class="v" id="hudCrane">—</div></div>
        <div class="row"><div class="k">Mode</div><div class="v" id="hudMode">PLAN</div></div>
        <div class="row"><div class="k">Level</div><div class="v" id="hudLevel">—</div></div>
        <div class="row"><div class="k">Score</div><div class="v" id="hudScore">0</div></div>

        <div class="bars">
          <div class="row"><div class="k">Utilisation (SIM)</div><div class="v"><span id="hudUtil">0%</span></div></div>
          <div class="bar warn"><i id="barUtil"></i></div>

          <div class="row"><div class="k">Swing</div><div class="v"><span id="hudSwing">0.0°</span></div></div>
          <div class="bar warn"><i id="barSwing"></i></div>

          <div class="row"><div class="k">Hook height</div><div class="v"><span id="hudH">—</span></div></div>
          <div class="bar"><i id="barH"></i></div>

          <div class="row"><div class="k">Radius</div><div class="v"><span id="hudR">—</span></div></div>
          <div class="bar"><i id="barR"></i></div>
        </div>

        <div class="pills">
          <span class="pill">Pick <span class="v" id="hudPick">—</span></span>
          <span class="pill">Set <span class="v" id="hudSet">—</span></span>
          <span class="pill">Zoom <span class="v" id="hudZoom">—</span></span>
        </div>
      </div>
    </div>

    <div class="hint" id="hint">PLAN mode: drag crane / pick / set targets in TOP view. Tick the Plan Gate → then “Operate”.</div>

    <!-- Touch controls -->
    <div class="touchUI" id="touchUI">
      <div class="touchPad" id="touchPad">
        <div class="joyBase"></div><div class="joyKnob" id="joyKnob"></div>
      </div>
      <div class="touchRight">
        <div class="hoist" id="hoist">
          <div class="track"></div>
          <div class="fill" id="hoistFill"></div>
          <div class="thumb" id="hoistThumb"></div>
        </div>
        <div class="touchBtns">
          <div class="tbtn" id="tAttach">HOOK<small>attach</small></div>
          <div class="tbtn" id="tPrec">PREC<small>fine</small></div>
          <div class="tbtn" id="tSlew">SLEW<small>left/right</small></div>
          <div class="tbtn" id="tLuff">LUFF<small>up/down</small></div>
        </div>
      </div>
    </div>

    <!-- Overlays -->
    <div class="overlay" id="ovHangar"><div class="panel">
      <div class="panelHead">
        <div>
          <h2>Crane Hangar</h2>
          <div class="sub">Pick a real crane model (game uses *SIM* capacity, not manufacturer load charts).</div>
        </div>
        <button class="btn small" data-close="ovHangar">Close</button>
      </div>
      <div class="grid" id="hangarGrid"></div>
    </div></div>

    <div class="overlay" id="ovLevels"><div class="panel">
      <div class="panelHead">
        <div>
          <h2>Levels</h2>
          <div class="sub">Each level is a “site puzzle”: set crane position, reach, clearance, swing control, place safely.</div>
        </div>
        <button class="btn small" data-close="ovLevels">Close</button>
      </div>
      <div class="grid" id="levelGrid"></div>
    </div></div>

    <div class="overlay" id="ovPlan"><div class="panel">
      <div class="panelHead">
        <div>
          <h2>Plan Gate (lift planning workflow)</h2>
          <div class="sub">Tick items to unlock OPERATE. This mimics good practice; it is not a real lift plan.</div>
        </div>
        <button class="btn small" data-close="ovPlan">Close</button>
      </div>

      <div class="editorBar">
        <button class="btn small" id="btnExportSVG">Export TOP view SVG</button>
        <button class="btn small" id="btnExportDXF">Export TOP view DXF</button>
        <span class="tag" id="gateStatus">Gate: locked</span>
      </div>

      <div class="grid">
        <div class="tile">
          <div class="tileTop"><b>Planning checklist</b><span class="tag ok">BS/EN style</span></div>
          <div class="mini">You can’t operate until the minimum gate is met.</div>
          <div class="field"><label><input type="checkbox" class="gate" data-key="ap"> Appointed Person / PIC assigned</label></div>
          <div class="field"><label><input type="checkbox" class="gate" data-key="scope"> Lift scope defined (pick, set, path, constraints)</label></div>
          <div class="field"><label><input type="checkbox" class="gate" data-key="crane"> Crane selected & configured (boom/cw/outriggers)</label></div>
          <div class="field"><label><input type="checkbox" class="gate" data-key="ground"> Ground & setup zone checked (SIM)</label></div>
          <div class="field"><label><input type="checkbox" class="gate" data-key="zone"> Exclusion zones set (SIM)</label></div>
          <div class="field"><label><input type="checkbox" class="gate" data-key="rigging"> Rigging plan confirmed (SIM)</label></div>
          <div class="field"><label><input type="checkbox" class="gate" data-key="comms"> Communications agreed (SIM)</label></div>
          <div class="field"><label><input type="checkbox" class="gate" data-key="weather"> Wind / weather within limit (SIM)</label></div>
        </div>

        <div class="tile">
          <div class="tileTop"><b>Plan checks (auto)</b><span class="tag" id="autoTag">checking…</span></div>
          <div class="stats">
            <div class="statline"><span>Reach to pick</span><b id="chkPick">—</b></div>
            <div class="statline"><span>Reach to set</span><b id="chkSet">—</b></div>
            <div class="statline"><span>Clearance</span><b id="chkClear">—</b></div>
            <div class="statline"><span>Utilisation (SIM)</span><b id="chkUtil">—</b></div>
            <div class="statline"><span>Collision risk</span><b id="chkCol">—</b></div>
          </div>
          <div class="mini">These are simplified “game checks” for pacing and training feel.</div>
        </div>
      </div>
    </div></div>

    <div class="overlay" id="ovStandards"><div class="panel">
      <div class="panelHead">
        <div>
          <h2>BS / EN framing (training mode)</h2>
          <div class="sub">What the game is *trying* to mirror — without pretending to be a lift plan tool.</div>
        </div>
        <button class="btn small" data-close="ovStandards">Close</button>
      </div>
      <div class="grid">
        <div class="tile">
          <div class="tileTop"><b>Reality check</b><span class="tag bad">Important</span></div>
          <div class="mini">
            This is a <b>game + training simulator</b>. It must <b>not</b> be used for actual lifting operations.
            Always use the manufacturer’s manual/load charts and competent planning/engineering.
          </div>
        </div>
        <div class="tile">
          <div class="tileTop"><b>BS 7121 style workflow</b><span class="tag ok">Planning</span></div>
          <div class="mini">
            The game “Plan Gate” is inspired by a typical UK approach: define scope, appoint responsibility,
            manage risks, control the lift, and verify the setup/conditions.
          </div>
        </div>
        <div class="tile">
          <div class="tileTop"><b>EN standards</b><span class="tag ok">Cranes</span></div>
          <div class="mini">
            EN crane standards focus heavily on design/safety requirements of cranes (e.g., mobile cranes, tower cranes).
            The game uses them as “category flavour”, not engineering validation.
          </div>
        </div>
      </div>
    </div></div>

    <div class="overlay" id="ovControls"><div class="panel">
      <div class="panelHead">
        <div>
          <h2>Controls</h2>
          <div class="sub">Desktop + Mobile. (On mobile, touch UI appears automatically.)</div>
        </div>
        <button class="btn small" data-close="ovControls">Close</button>
      </div>
      <div class="grid">
        <div class="tile">
          <div class="tileTop"><b>Desktop</b><span class="tag">Operate</span></div>
          <div class="mini">
            <div>Move base: <span class="kbd">A/D</span> or <span class="kbd">←/→</span></div>
            <div>Hoist: <span class="kbd">W/S</span> or <span class="kbd">↑/↓</span></div>
            <div>Slew: <span class="kbd">J/L</span></div>
            <div>Luff: <span class="kbd">I/K</span></div>
            <div>Telescope (where supported): <span class="kbd">U/O</span></div>
            <div>Attach/Detach: <span class="kbd">Space</span></div>
            <div>Precision: <span class="kbd">Shift</span></div>
            <div>Pan/Zoom TOP view: mouse drag / wheel (or trackpad)</div>
          </div>
        </div>
        <div class="tile">
          <div class="tileTop"><b>Plan mode (Desktop + Mobile)</b><span class="tag">CAD style</span></div>
          <div class="mini">
            In TOP view, drag:
            <ul>
              <li><b>Crane base</b> (cyan)</li>
              <li><b>Pick point</b> (magenta)</li>
              <li><b>Set point</b> (green)</li>
            </ul>
            Obstacles are red “no-go” blocks with a height (used for clearance warnings in SIDE view).
          </div>
        </div>
      </div>
    </div></div>

    <div class="overlay" id="ovSettings"><div class="panel">
      <div class="panelHead">
        <div>
          <h2>Settings</h2>
          <div class="sub">Visual + difficulty.</div>
        </div>
        <button class="btn small" data-close="ovSettings">Close</button>
      </div>
      <div class="grid">
        <div class="tile">
          <div class="tileTop"><b>Visual</b><span class="tag">CAD</span></div>
          <div class="field"><label>AutoCAD grid
            <select id="setGrid">
              <option value="1">On</option>
              <option value="0">Off</option>
            </select>
          </label></div>
          <div class="field"><label>Dimensions
            <select id="setDims">
              <option value="1">On</option>
              <option value="0">Off</option>
            </select>
          </label></div>
          <div class="field"><label>Viewport split
            <select id="setSplit">
              <option value="auto">Auto</option>
              <option value="wide">Wide (side right)</option>
              <option value="tall">Tall (side bottom)</option>
            </select>
          </label></div>
        </div>
        <div class="tile">
          <div class="tileTop"><b>Difficulty</b><span class="tag">Game</span></div>
          <div class="field"><label>Swing multiplier
            <select id="setSwing">
              <option value="0.8">Easy</option>
              <option value="1" selected>Normal</option>
              <option value="1.3">Hard</option>
            </select>
          </label></div>
          <div class="field"><label>Wind gusts (SIM)
            <select id="setWind">
              <option value="0">Off</option>
              <option value="1" selected>On</option>
            </select>
          </label></div>
        </div>
      </div>
    </div></div>

  </main>
</div>

<script>
(() => {
  // =========================
  // Safety / scope disclaimer
  // =========================
  // This is a GAME + TRAINING SIM. It deliberately uses SIMPLIFIED logic and MUST NOT be used for real lifting operations.

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const dist = (ax,ay,bx,by) => Math.hypot(ax-bx, ay-by);
  const fmt = (n, d=1) => (Math.round(n*10**d)/10**d).toFixed(d);
  const rad2deg = r => r * 180/Math.PI;
  const deg2rad = d => d * Math.PI/180;

  function nowMs(){ return performance.now(); }

  // ---------- Storage ----------
  const KEY = "craneops_cad_v1";
  const loadSave = () => {
    try { return JSON.parse(localStorage.getItem(KEY) || "{}"); } catch { return {}; }
  };
  const saveSave = (s) => localStorage.setItem(KEY, JSON.stringify(s));
  const S = loadSave();

  // ---------- UI ----------
  const $ = (id) => document.getElementById(id);

  const overlays = ["ovHangar","ovLevels","ovPlan","ovStandards","ovControls","ovSettings"].reduce((m,k)=> (m[k]=$(k),m), {});
  function openOv(name){ Object.values(overlays).forEach(o=>o.classList.remove("on")); overlays[name].classList.add("on"); }
  function closeAllOv(){ Object.values(overlays).forEach(o=>o.classList.remove("on")); }
  document.querySelectorAll("[data-close]").forEach(b=>{
    b.addEventListener("click", () => overlays[b.getAttribute("data-close")].classList.remove("on"));
  });

  // Buttons
  $("btnHangar").onclick = () => openOv("ovHangar");
  $("btnLevels").onclick = () => openOv("ovLevels");
  $("btnPlan").onclick = () => openOv("ovPlan");
  $("btnStandards").onclick = () => openOv("ovStandards");
  $("btnControls").onclick = () => openOv("ovControls");
  $("btnSettings").onclick = () => openOv("ovSettings");

  // HUD
  const hud = {
    crane: $("hudCrane"), mode:$("hudMode"), level:$("hudLevel"), score:$("hudScore"),
    util:$("hudUtil"), swing:$("hudSwing"), h:$("hudH"), r:$("hudR"), zoom:$("hudZoom"),
    pick:$("hudPick"), set:$("hudSet"),
    barUtil:$("barUtil"), barSwing:$("barSwing"), barH:$("barH"), barR:$("barR"),
    hint:$("hint")
  };

  // Plan checks UI
  const gateStatus = $("gateStatus");
  const autoTag = $("autoTag");
  const chkPick = $("chkPick"), chkSet = $("chkSet"), chkClear=$("chkClear"), chkUtil=$("chkUtil"), chkCol=$("chkCol");
  const gateChecks = [...document.querySelectorAll(".gate")];

  // Settings
  const settings = {
    grid: S.grid ?? 1,
    dims: S.dims ?? 1,
    split: S.split ?? "auto",
    swingMul: parseFloat(S.swingMul ?? "1"),
    wind: S.wind ?? 1,
  };
  $("setGrid").value = String(settings.grid);
  $("setDims").value = String(settings.dims);
  $("setSplit").value = settings.split;
  $("setSwing").value = String(settings.swingMul);
  $("setWind").value = String(settings.wind);

  $("setGrid").onchange = (e)=>{ settings.grid = +e.target.value; S.grid=settings.grid; saveSave(S); };
  $("setDims").onchange = (e)=>{ settings.dims = +e.target.value; S.dims=settings.dims; saveSave(S); };
  $("setSplit").onchange = (e)=>{ settings.split = e.target.value; S.split=settings.split; saveSave(S); };
  $("setSwing").onchange = (e)=>{ settings.swingMul = parseFloat(e.target.value); S.swingMul=String(settings.swingMul); saveSave(S); };
  $("setWind").onchange = (e)=>{ settings.wind = +e.target.value; S.wind=settings.wind; saveSave(S); };

  // ---------- Crane roster (real models, SIM behaviour) ----------
  // Specs below are high-level public “headline” specs (capacity/boom etc). This game still uses SIM curves.
  const cranes = [
    { id:"ltm1110", brand:"Liebherr", model:"LTM 1110-5.2", type:"TEL",  headline:"110 t • 60 m boom", maxCapT:110, boomMin:13, boomMax:60, baseH:2.2, move:1.8, slew:0.9, luff:0.55, tel:0.8, hoist:1.6, note:"Fast 5-axle all-terrain feel." },
    { id:"gmk5250", brand:"Grove", model:"GMK5250XL-1", type:"TEL",  headline:"250 t • 78.5 m boom", maxCapT:250, boomMin:15, boomMax:78.5, baseH:2.5, move:1.7, slew:0.85, luff:0.50, tel:0.70, hoist:1.45, note:"Big reach, steady control." },
    { id:"ac5250", brand:"Tadano", model:"AC 5.250-2", type:"TEL",  headline:"250 t • 70 m boom", maxCapT:250, boomMin:13.4, boomMax:70, baseH:2.4, move:1.7, slew:0.88, luff:0.52, tel:0.75, hoist:1.5, note:"Crisp slewing + good mid-radius." },
    { id:"lr1300", brand:"Liebherr", model:"LR 1300.1 SX", type:"CRAWLER", headline:"300 t • crawler", maxCapT:300, boomMin:20, boomMax:92, baseH:2.0, move:1.1, slew:0.62, luff:0.45, tel:0.0, hoist:1.3, note:"Slow travel, monster stability." },
    { id:"ltm1450", brand:"Liebherr", model:"LTM 1450-8.1", type:"TEL", headline:"450 t • 85 m boom", maxCapT:450, boomMin:18, boomMax:85, baseH:2.7, move:1.5, slew:0.78, luff:0.45, tel:0.62, hoist:1.25, note:"Heavy iron: rewards planning." },
    { id:"gmk6400", brand:"Grove", model:"GMK6400-1", type:"TEL",  headline:"400 t • 60 m boom", maxCapT:400, boomMin:16, boomMax:60, baseH:2.6, move:1.45, slew:0.76, luff:0.46, tel:0.62, hoist:1.25, note:"High capacity, compact boom." },
    { id:"ac7450", brand:"Tadano", model:"AC 7.450-1", type:"TEL",  headline:"450 t class • 80 m boom", maxCapT:450, boomMin:15, boomMax:80, baseH:2.7, move:1.45, slew:0.76, luff:0.45, tel:0.60, hoist:1.22, note:"Long boom, heavy class." },
    { id:"mk140", brand:"Liebherr", model:"MK 140-5.1E", type:"TOWER", headline:"8 t • 65 m radius", maxCapT:8, boomMin:10, boomMax:65, baseH:3.2, move:1.2, slew:0.80, luff:0.0, tel:0.0, hoist:1.55, note:"Tower-style: trolley radius game." },
  ];

  // Unlocks: start with first 2.
  S.unlock = S.unlock ?? { ltm1110:true, gmk5250:true };
  function isUnlocked(id){ return !!S.unlock?.[id]; }
  function unlock(id){ S.unlock[id]=true; saveSave(S); }

  // ---------- Levels (site puzzles) ----------
  // World units are “metres” for readability (still game SIM).
  const levels = [
    {
      id:"yard_01", name:"Yard Warm-up", tier:1,
      bounds:{w:120,h:80},
      obstacles:[
        {x:64,y:18,w:22,h:12,z:10, name:"Pipe rack"},
        {x:30,y:52,w:20,h:10,z:6, name:"Containers"},
      ],
      pick:{x:18,y:18, z:0, massT:10, w:4, h:2, rot:0},
      set:{x:102,y:62, z:0, },
      rules:{ maxUtil:0.95, maxSwingDeg:17, maxCollisions:0 },
      medal:{ bronze:80, silver:120, gold:170 }
    },
    {
      id:"site_02", name:"Tight Access", tier:2,
      bounds:{w:140,h:90},
      obstacles:[
        {x:60,y:30,w:30,h:14,z:14, name:"Steel frame"},
        {x:36,y:70,w:34,h:10,z:9, name:"Site cabins"},
        {x:98,y:22,w:20,h:16,z:18, name:"Substation"},
      ],
      pick:{x:26,y:20,z:0, massT:18, w:5, h:2.5, rot:15},
      set:{x:122,y:78,z:0},
      rules:{ maxUtil:0.90, maxSwingDeg:14, maxCollisions:0 },
      medal:{ bronze:100, silver:150, gold:210 }
    },
    {
      id:"plant_03", name:"Process Plant Hop", tier:3,
      bounds:{w:180,h:110},
      obstacles:[
        {x:72,y:28,w:44,h:18,z:20, name:"Module bay"},
        {x:118,y:70,w:40,h:16,z:16, name:"Pipe bridge"},
        {x:42,y:78,w:26,h:12,z:10, name:"Stores"},
      ],
      pick:{x:22,y:24,z:0, massT:35, w:6, h:3, rot:-10},
      set:{x:162,y:88,z:0},
      rules:{ maxUtil:0.88, maxSwingDeg:12, maxCollisions:0 },
      medal:{ bronze:130, silver:190, gold:270 }
    },
    {
      id:"tower_04", name:"MK Tower Shuffle", tier:2,
      bounds:{w:120,h:120},
      obstacles:[
        {x:48,y:44,w:24,h:24,z:22, name:"Building core"},
        {x:86,y:18,w:20,h:20,z:14, name:"Laydown"},
      ],
      pick:{x:18,y:92,z:0, massT:4.5, w:3, h:1.6, rot:0},
      set:{x:98,y:98,z:0},
      rules:{ maxUtil:0.92, maxSwingDeg:16, maxCollisions:0 },
      medal:{ bronze:90, silver:135, gold:190 }
    },
  ];

  // Saved best scores
  S.best = S.best ?? {}; // levelId -> score

  // ---------- Game state ----------
  const state = {
    levelIndex: 0,
    craneId: (S.craneId && cranes.some(c=>c.id===S.craneId)) ? S.craneId : "ltm1110",
    mode: "PLAN", // PLAN or OPERATE
    score: 0,
    collisions: 0,
    attached: false,
    precision: false,
    timeStart: nowMs(),
  };

  function getCrane(){ return cranes.find(c=>c.id===state.craneId) || cranes[0]; }
  function getLevel(){ return levels[state.levelIndex]; }

  // ---------- World objects ----------
  // Camera for TOP view
  const cam = {
    x: 60, y: 40, zoom: 6.5, // pixels per metre-ish (adjusted in resize)
    dragging:false, dragKind:null, // "pan" | "crane" | "pick" | "set"
    dragOff:{x:0,y:0},
  };

  // Crane configuration (SIM)
  const crane = {
    x: 40, y: 40,         // base in top view
    slew: 0,              // radians
    boomL: 45,            // metres
    luff: deg2rad(55),    // boom angle above horizontal
    hoist: 12,            // hook line length below tip (m)
    trolley: 28,          // for TOWER type: radius along jib
  };

  // Load (SIM)
  const load = {
    x: 0, y: 0,           // in top view
    vx: 0, vy: 0,
    rot: 0, vr: 0,
    z: 0,                 // on ground = 0
  };

  // ---------- Input ----------
  const keys = new Set();
  window.addEventListener("keydown", (e)=>{
    if (["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (e.code==="Space") toggleAttach();
    if (e.code==="ShiftLeft"||e.code==="ShiftRight") state.precision = true;
    if (e.code==="Escape") closeAllOv();
  }, {passive:false});
  window.addEventListener("keyup", (e)=>{
    keys.delete(e.code);
    if (e.code==="ShiftLeft"||e.code==="ShiftRight") state.precision = false;
  });

  // Touch controls -> update axes
  const touch = {
    active:false,
    moveX:0, moveY:0, // left joystick
    hoist:0,          // -1..+1 (up/down)
    slew:0,           // -1..+1
    luff:0,           // -1..+1
    precision:false,
  };

  const isMobile = () => matchMedia("(pointer: coarse)").matches;
  const touchUI = $("touchUI");
  function updateTouchUI(){
    const on = isMobile();
    touchUI.classList.toggle("on", on);
  }
  updateTouchUI();
  window.addEventListener("resize", updateTouchUI);

  const joy = { id:null, cx:0, cy:0, kx:0, ky:0 };
  const pad = $("touchPad"), knob = $("joyKnob");
  pad.addEventListener("pointerdown", (e)=>{
    pad.setPointerCapture(e.pointerId);
    joy.id = e.pointerId;
    const r = pad.getBoundingClientRect();
    joy.cx = r.left + r.width/2; joy.cy = r.top + r.height/2;
    joy.kx = e.clientX; joy.ky = e.clientY;
    onJoyMove(e);
  });
  pad.addEventListener("pointermove", (e)=>{ if(e.pointerId===joy.id) onJoyMove(e); });
  pad.addEventListener("pointerup", (e)=>{ if(e.pointerId===joy.id) { joy.id=null; touch.moveX=0; touch.moveY=0; renderJoy(0,0); } });
  function onJoyMove(e){
    const r = pad.getBoundingClientRect();
    const max = Math.min(r.width, r.height)*0.34;
    const dx = e.clientX - joy.cx, dy = e.clientY - joy.cy;
    const m = Math.hypot(dx,dy) || 1;
    const ndx = (m>max) ? dx/m*max : dx;
    const ndy = (m>max) ? dy/m*max : dy;
    touch.moveX = clamp(ndx/max, -1, 1);
    touch.moveY = clamp(ndy/max, -1, 1);
    renderJoy(ndx, ndy);
  }
  function renderJoy(dx,dy){
    knob.style.left = `calc(50% + ${dx}px)`;
    knob.style.top  = `calc(50% + ${dy}px)`;
  }

  // Hoist slider
  const ho = { id:null, pct:0.5 };
  const hoistEl = $("hoist"), hoFill=$("hoistFill"), hoThumb=$("hoistThumb");
  hoistEl.addEventListener("pointerdown", (e)=>{
    hoistEl.setPointerCapture(e.pointerId);
    ho.id = e.pointerId;
    onHoMove(e);
  });
  hoistEl.addEventListener("pointermove", (e)=>{ if(e.pointerId===ho.id) onHoMove(e); });
  hoistEl.addEventListener("pointerup", (e)=>{ if(e.pointerId===ho.id) { ho.id=null; touch.hoist=0; } });
  function onHoMove(e){
    const r = hoistEl.getBoundingClientRect();
    const y = clamp((e.clientY - r.top) / r.height, 0, 1);
    ho.pct = y;
    // Map: top=hoist up (-1), bottom=down (+1)
    touch.hoist = clamp((y - 0.5) * 2, -1, 1);
    hoFill.style.height = `${(1-y)*100}%`;
    hoThumb.style.top = `calc(${y*100}% - 27px)`;
  }

  // Buttons
  const tAttach=$("tAttach"), tPrec=$("tPrec"), tSlew=$("tSlew"), tLuff=$("tLuff");
  tAttach.addEventListener("pointerdown", ()=>toggleAttach());
  tPrec.addEventListener("pointerdown", ()=>{
    touch.precision = !touch.precision;
    tPrec.classList.toggle("on", touch.precision);
  });
  // Slew + luff toggles: hold-to-use
  let slewHold=false, luffHold=false;
  tSlew.addEventListener("pointerdown", (e)=>{ tSlew.setPointerCapture(e.pointerId); slewHold=true; });
  tSlew.addEventListener("pointerup", ()=>{ slewHold=false; touch.slew=0; });
  tSlew.addEventListener("pointermove", (e)=>{
    if(!slewHold) return;
    const r = tSlew.getBoundingClientRect();
    touch.slew = clamp(((e.clientX - r.left)/r.width - 0.5)*2, -1, 1);
  });

  tLuff.addEventListener("pointerdown", (e)=>{ tLuff.setPointerCapture(e.pointerId); luffHold=true; });
  tLuff.addEventListener("pointerup", ()=>{ luffHold=false; touch.luff=0; });
  tLuff.addEventListener("pointermove", (e)=>{
    if(!luffHold) return;
    const r = tLuff.getBoundingClientRect();
    // top = luff up (+), bottom = down (-)
    const y = (e.clientY - r.top)/r.height;
    touch.luff = clamp((0.5 - y)*2, -1, 1);
  });

  // ---------- Canvas ----------
  const canvas = $("c");
  const ctx = canvas.getContext("2d");
  let W=0,H=0,DPR=1;

  function resize(){
    DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    W = canvas.clientWidth; H = canvas.clientHeight;
    canvas.width = Math.floor(W*DPR);
    canvas.height = Math.floor(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    // sensible default zoom based on viewport
    const lv = getLevel();
    cam.zoom = Math.min(10, Math.max(3.6, Math.min(W,H) / Math.max(lv.bounds.w, lv.bounds.h) * 0.84));
  }
  window.addEventListener("resize", resize);
  resize();

  // ---------- Viewport layout ----------
  function getLayout(){
    const split = settings.split;
    const isWide = (W/H) >= 1.25;
    const mode = (split==="auto") ? (isWide ? "wide" : "tall") : split;

    const pad = 10;
    if(mode==="wide"){
      const leftW = Math.floor(W*0.64);
      return {
        mode,
        top:  {x:pad, y:pad, w:leftW - pad*1.5, h:H - pad*2},
        side: {x:leftW, y:pad, w:W-leftW - pad, h:H - pad*2},
      };
    } else {
      const topH = Math.floor(H*0.60);
      return {
        mode,
        top:  {x:pad, y:pad, w:W - pad*2, h:topH - pad*1.5},
        side: {x:pad, y:topH, w:W - pad*2, h:H-topH - pad},
      };
    }
  }

  // ---------- Coordinate transforms ----------
  function worldToTopPx(wx, wy, vp){
    const x = (wx - cam.x)*cam.zoom + (vp.x + vp.w/2);
    const y = (wy - cam.y)*cam.zoom + (vp.y + vp.h/2);
    return {x,y};
  }
  function topPxToWorld(px, py, vp){
    const wx = (px - (vp.x + vp.w/2))/cam.zoom + cam.x;
    const wy = (py - (vp.y + vp.h/2))/cam.zoom + cam.y;
    return {x:wx,y:wy};
  }

  // Side view is a section along crane slew direction, distance along boom line = s
  // We'll map: x_axis = distance from crane base along slew direction, y_axis = height (z)
  const sideCam = { s:0, z:12, zoom: 6.0 };
  function sideToPx(s, z, vp){
    const x = (s - sideCam.s)*sideCam.zoom + (vp.x + vp.w*0.18);
    const y = (vp.y + vp.h*0.86) - (z - sideCam.z)*sideCam.zoom;
    return {x,y};
  }

  // ---------- Entities (level init) ----------
  function resetToLevel(idx){
    state.levelIndex = idx;
    state.score = 0;
    state.collisions = 0;
    state.attached = false;
    state.mode = "PLAN";
    state.timeStart = nowMs();

    // Default positions
    const lv = getLevel();
    cam.x = lv.bounds.w/2; cam.y = lv.bounds.h/2;

    crane.x = lv.bounds.w*0.45;
    crane.y = lv.bounds.h*0.55;
    crane.slew = -Math.PI/8;
    const c = getCrane();
    crane.boomL = clamp(lv.bounds.w*0.36, c.boomMin, c.boomMax);
    crane.luff  = deg2rad(55);
    crane.hoist = 12;

    if(c.type==="TOWER"){
      crane.trolley = 28;
      crane.luff = deg2rad(70); // used as a cosmetic
    }

    // Load at pick
    load.x = lv.pick.x;
    load.y = lv.pick.y;
    load.vx = load.vy = 0;
    load.rot = deg2rad(lv.pick.rot || 0);
    load.vr = 0;
    load.z = 0;

    // Gate checkboxes default to saved or reset
    const gate = S.gate ?? {};
    gateChecks.forEach(cb => cb.checked = !!gate[cb.dataset.key]);
    computePlanGate();
    updateHud();
  }

  // ---------- Panels build ----------
  function buildHangar(){
    const grid = $("hangarGrid");
    grid.innerHTML = "";
    cranes.forEach(c=>{
      const unlocked = isUnlocked(c.id);
      const el = document.createElement("div");
      el.className = "tile" + (unlocked ? "" : " locked");
      el.innerHTML = `
        <div class="tileTop">
          <div>
            <b>${c.brand} ${c.model}</b>
            <div class="mini">${c.headline}</div>
          </div>
          <span class="tag ${unlocked ? "ok" : "bad"}">${unlocked ? "Unlocked" : "Locked"}</span>
        </div>
        <div class="stats">
          <div class="statline"><span>Type</span><b>${c.type}</b></div>
          <div class="statline"><span>Max (headline)</span><b>${c.maxCapT} t</b></div>
          <div class="statline"><span>Boom</span><b>${c.boomMin}–${c.boomMax} m</b></div>
        </div>
        <div class="mini">${c.note}</div>
        <div class="tileBtns">
          <button class="btn small ${unlocked ? "primary" : ""}" ${unlocked ? "" : "disabled"}>Select</button>
          ${unlocked ? "" : `<button class="btn small">Unlock (demo)</button>`}
        </div>
      `;
      const [selectBtn, unlockBtn] = el.querySelectorAll("button");
      selectBtn?.addEventListener("click", ()=>{
        state.craneId = c.id; S.craneId = c.id; saveSave(S);
        closeAllOv(); resetToLevel(state.levelIndex);
      });
      unlockBtn?.addEventListener("click", ()=>{
        unlock(c.id);
        buildHangar();
      });
      grid.appendChild(el);
    });
  }

  function buildLevels(){
    const grid = $("levelGrid");
    grid.innerHTML = "";
    levels.forEach((lv, i)=>{
      const best = S.best[lv.id] ?? null;
      const el = document.createElement("div");
      el.className = "tile";
      el.innerHTML = `
        <div class="tileTop">
          <div>
            <b>${lv.name}</b>
            <div class="mini">Tier ${lv.tier} • ${lv.bounds.w}×${lv.bounds.h} m</div>
          </div>
          <span class="tag">Best: ${best ?? "—"}</span>
        </div>
        <div class="stats">
          <div class="statline"><span>Load</span><b>${lv.pick.massT} t</b></div>
          <div class="statline"><span>Obstacles</span><b>${lv.obstacles.length}</b></div>
          <div class="statline"><span>Rules</span><b>util ≤ ${Math.round(lv.rules.maxUtil*100)}%</b></div>
        </div>
        <div class="tileBtns">
          <button class="btn small primary">Load level</button>
        </div>
      `;
      el.querySelector("button").addEventListener("click", ()=>{
        closeAllOv();
        resetToLevel(i);
      });
      grid.appendChild(el);
    });
  }

  // ---------- Plan gate ----------
  function computePlanGate(){
    const gate = {};
    gateChecks.forEach(cb => gate[cb.dataset.key] = cb.checked);
    S.gate = gate; saveSave(S);

    // Minimum gate: AP + scope + crane + ground + zone
    const minOk = !!(gate.ap && gate.scope && gate.crane && gate.ground && gate.zone);
    gateStatus.textContent = `Gate: ${minOk ? "ready" : "locked"}`;
    gateStatus.className = "tag " + (minOk ? "ok" : "bad");
    return minOk;
  }
  gateChecks.forEach(cb => cb.addEventListener("change", computePlanGate));

  // Operate button
  $("btnPlay").onclick = () => {
    const ok = computePlanGate();
    if(!ok){
      openOv("ovPlan");
      return;
    }
    state.mode = "OPERATE";
    closeAllOv();
    updateHud();
  };

  // Restart
  $("btnRestart").onclick = () => resetToLevel(state.levelIndex);

  // ---------- Attach / detach ----------
  function getHook(){
    const c = getCrane();
    if(c.type==="TOWER"){
      const r = clamp(crane.trolley, 5, c.boomMax);
      const hx = crane.x + r*Math.cos(crane.slew);
      const hy = crane.y + r*Math.sin(crane.slew);
      const tipZ = c.baseH + 38; // tower mast height (SIM)
      const hookZ = clamp(tipZ - crane.hoist, 0, 80);
      return {x:hx,y:hy,z:hookZ,r};
    } else {
      const L = clamp(crane.boomL, c.boomMin, c.boomMax);
      const theta = clamp(crane.luff, deg2rad(15), deg2rad(82));
      const r = L*Math.cos(theta);
      const tipZ = c.baseH + L*Math.sin(theta);
      const hookZ = clamp(tipZ - crane.hoist, 0, tipZ);
      const hx = crane.x + r*Math.cos(crane.slew);
      const hy = crane.y + r*Math.sin(crane.slew);
      return {x:hx,y:hy,z:hookZ,r};
    }
  }

  function toggleAttach(){
    if(state.mode!=="OPERATE") return;
    const lv = getLevel();
    const hk = getHook();
    const near = dist(load.x,load.y,hk.x,hk.y) < 2.2;
    const onGround = load.z < 0.25;
    if(!state.attached){
      if(near && onGround){
        state.attached = true;
        state.score += 10;
      }
    } else {
      // Detach: if within set zone and close to ground
      const nearSet = dist(load.x,load.y,lv.set.x,lv.set.y) < 3.5;
      if(nearSet && hk.z < 2.2){
        state.attached = false;
        load.z = 0;
        state.score += 70;
        // Win condition
        const time = (nowMs() - state.timeStart)/1000;
        const bonus = Math.max(0, 120 - time);
        const utilPenalty = Math.max(0, (state._utilPeak ?? 0) - lv.rules.maxUtil) * 200;
        const swingPenalty = Math.max(0, (state._swingPeak ?? 0) - lv.rules.maxSwingDeg) * 6;
        const colPenalty = state.collisions * 250;
        const final = Math.max(0, Math.floor(state.score + bonus - utilPenalty - swingPenalty - colPenalty));
        state.score = final;

        // save best
        const best = S.best[lv.id] ?? 0;
        if(final > best) { S.best[lv.id] = final; saveSave(S); }

        // unlock next crane (tiny reward loop)
        const eligible = cranes.filter(c=>!isUnlocked(c.id));
        if(eligible.length){
          unlock(eligible[0].id);
        }
        state.mode = "PLAN";
        openOv("ovLevels");
      }
    }
    updateHud();
  }

  // ---------- SIMPLE SIM "capacity curve" ----------
  // Not a load chart. This is deliberately fake/gamey.
  function capAtRadiusT(cr, r){
    // Crude curve: falls with radius; also affected by boom length (heavier boom = slightly less cap)
    const L = clamp(crane.boomL, cr.boomMin, cr.boomMax);
    const r0 = 8 + (cr.maxCapT>200? 10 : 6);
    const base = cr.maxCapT * (r0 / (r + r0));
    const boomPenalty = lerp(0.92, 0.72, (L - cr.boomMin)/(cr.boomMax - cr.boomMin + 1e-6));
    const typeBoost = (cr.type==="CRAWLER") ? 1.08 : 1.0;
    const towerBoost = (cr.type==="TOWER") ? 0.78 : 1.0;
    return Math.max(0.5, base * boomPenalty * typeBoost * towerBoost);
  }

  // ---------- Collision (OBB load footprint vs AABB obstacles) ----------
  function obbAabbCollide(ox,oy,ow,oh, theta, ax,ay,aw,ah){
    // OBB corners
    const cx=ox, cy=oy;
    const hw=ow/2, hh=oh/2;
    const c=Math.cos(theta), s=Math.sin(theta);
    const pts = [
      {x: cx + ( c*hw - s*hh), y: cy + ( s*hw + c*hh)},
      {x: cx + (-c*hw - s*hh), y: cy + (-s*hw + c*hh)},
      {x: cx + (-c*hw + s*hh), y: cy + (-s*hw - c*hh)},
      {x: cx + ( c*hw + s*hh), y: cy + ( s*hw - c*hh)},
    ];

    // Axes: OBB normals + world X/Y
    const axes = [
      {x: c, y: s},
      {x:-s, y: c},
      {x: 1, y: 0},
      {x: 0, y: 1},
    ];

    const aMinX = ax - aw/2, aMaxX = ax + aw/2;
    const aMinY = ay - ah/2, aMaxY = ay + ah/2;

    for(const axv of axes){
      // project OBB
      let minO=Infinity, maxO=-Infinity;
      for(const p of pts){
        const pr = p.x*axv.x + p.y*axv.y;
        minO = Math.min(minO, pr);
        maxO = Math.max(maxO, pr);
      }
      // project AABB corners
      const corners = [
        {x:aMinX,y:aMinY},{x:aMaxX,y:aMinY},{x:aMaxX,y:aMaxY},{x:aMinX,y:aMaxY}
      ];
      let minA=Infinity, maxA=-Infinity;
      for(const p of corners){
        const pr = p.x*axv.x + p.y*axv.y;
        minA = Math.min(minA, pr);
        maxA = Math.max(maxA, pr);
      }
      if(maxO < minA || maxA < minO) return false;
    }
    return true;
  }

  // ---------- Clearance check (ray from crane to load passes over obstacle) ----------
  function clearanceOK(hookZ){
    const lv = getLevel();
    // if any obstacle intersects the segment base->load then require hookZ above obstacle height + margin
    const bx = crane.x, by = crane.y;
    const lx = load.x, ly = load.y;
    const dx = lx - bx, dy = ly - by;
    const segLen = Math.hypot(dx,dy) + 1e-9;

    for(const o of lv.obstacles){
      // AABB segment intersection (Liang–Barsky style)
      const minX = o.x - o.w/2, maxX = o.x + o.w/2;
      const minY = o.y - o.h/2, maxY = o.y + o.h/2;

      let t0=0, t1=1;
      const p = [-dx, dx, -dy, dy];
      const q = [bx - minX, maxX - bx, by - minY, maxY - by];
      let ok = true;
      for(let i=0;i<4;i++){
        if(Math.abs(p[i]) < 1e-9){
          if(q[i] < 0){ ok=false; break; }
        } else {
          const t = q[i]/p[i];
          if(p[i] < 0){ t0 = Math.max(t0, t); }
          else { t1 = Math.min(t1, t); }
          if(t0 > t1){ ok=false; break; }
        }
      }
      if(ok){
        const margin = 1.5; // metres (SIM)
        const required = o.z + margin;
        if(hookZ < required) return false;
      }
    }
    return true;
  }

  // ---------- Plan checks (auto) ----------
  function updatePlanChecks(){
    const lv = getLevel();
    const cr = getCrane();
    const hk = getHook();

    const rp = dist(crane.x,crane.y, lv.pick.x, lv.pick.y);
    const rs = dist(crane.x,crane.y, lv.set.x, lv.set.y);
    const capP = capAtRadiusT(cr, rp);
    const utilP = lv.pick.massT / capP;

    const pickOK = rp <= hk.r + 0.8; // hook radius is current
    const setOK = rs <= hk.r + 0.8;
    const clearOK = clearanceOK(hk.z);
    const colRisk = lv.obstacles.some(o => {
      // risk if current load footprint overlaps any obstacle footprint (top view)
      const lw = lv.pick.w, lh = lv.pick.h;
      return obbAabbCollide(load.x,load.y, lw,lh, load.rot, o.x,o.y,o.w,o.h);
    });

    chkPick.textContent = pickOK ? "OK" : "NO";
    chkPick.style.color = pickOK ? "var(--ok)" : "var(--bad)";
    chkSet.textContent = setOK ? "OK" : "NO";
    chkSet.style.color = setOK ? "var(--ok)" : "var(--bad)";
    chkClear.textContent = clearOK ? "OK" : "LOW";
    chkClear.style.color = clearOK ? "var(--ok)" : "var(--warn)";
    chkUtil.textContent = `${Math.round(utilP*100)}%`;
    chkUtil.style.color = utilP <= lv.rules.maxUtil ? "var(--ok)" : "var(--bad)";
    chkCol.textContent = colRisk ? "RISK" : "OK";
    chkCol.style.color = colRisk ? "var(--warn)" : "var(--ok)";

    const ok = pickOK && setOK && clearOK && !colRisk && utilP <= (lv.rules.maxUtil+0.08);
    autoTag.textContent = ok ? "looks good" : "needs work";
    autoTag.className = "tag " + (ok ? "ok" : "bad");
  }

  // ---------- HUD update ----------
  function updateHud(){
    const lv = getLevel();
    const cr = getCrane();
    hud.crane.textContent = `${cr.brand} ${cr.model}`;
    hud.level.textContent = lv.name;
    hud.mode.textContent = state.mode;
    hud.score.textContent = String(state.score);
    hud.pick.textContent = `${lv.pick.massT}t`;
    hud.set.textContent = `(${Math.round(lv.set.x)},${Math.round(lv.set.y)})`;
  }

  // ---------- Export SVG / DXF (TOP view) ----------
  function exportTopSVG(){
    const lv = getLevel();
    const cr = getCrane();

    // Simple SVG with obstacles, pick/set, crane base, radius line to hook
    const hk = getHook();
    const pad = 10;
    const w = 1000, h = 700;
    const sx = (w - pad*2) / lv.bounds.w;
    const sy = (h - pad*2) / lv.bounds.h;
    const s = Math.min(sx, sy);

    function tx(x){ return pad + x*s; }
    function ty(y){ return pad + y*s; }

    let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
    svg += `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">\n`;
    svg += `<rect width="100%" height="100%" fill="#0b1220"/>\n`;
    svg += `<g stroke="#2a3a52" stroke-width="1" opacity="0.55">\n`;
    for(let x=0;x<=lv.bounds.w;x+=10) svg += `<line x1="${tx(x)}" y1="${ty(0)}" x2="${tx(x)}" y2="${ty(lv.bounds.h)}"/>\n`;
    for(let y=0;y<=lv.bounds.h;y+=10) svg += `<line x1="${tx(0)}" y1="${ty(y)}" x2="${tx(lv.bounds.w)}" y2="${ty(y)}"/>\n`;
    svg += `</g>\n`;

    // Obstacles
    svg += `<g fill="none" stroke="#ff4d6d" stroke-width="2">\n`;
    lv.obstacles.forEach(o=>{
      svg += `<rect x="${tx(o.x - o.w/2)}" y="${ty(o.y - o.h/2)}" width="${o.w*s}" height="${o.h*s}"/>\n`;
    });
    svg += `</g>\n`;

    // Pick/Set points
    svg += `<circle cx="${tx(lv.pick.x)}" cy="${ty(lv.pick.y)}" r="${7}" fill="#ff74d4"/>\n`;
    svg += `<circle cx="${tx(lv.set.x)}" cy="${ty(lv.set.y)}" r="${7}" fill="#43f59a"/>\n`;

    // Crane base + hook line
    svg += `<circle cx="${tx(crane.x)}" cy="${ty(crane.y)}" r="${9}" fill="#33f6ff"/>\n`;
    svg += `<line x1="${tx(crane.x)}" y1="${ty(crane.y)}" x2="${tx(hk.x)}" y2="${ty(hk.y)}" stroke="#ffd166" stroke-width="2"/>\n`;
    // Hook
    svg += `<circle cx="${tx(hk.x)}" cy="${ty(hk.y)}" r="${5}" fill="#ffd166"/>\n`;

    svg += `<text x="${pad}" y="${pad+16}" fill="#e9eef7" font-family="monospace" font-size="14">Crane Ops TOP view (SIM) — ${cr.brand} ${cr.model}</text>\n`;
    svg += `</svg>\n`;

    downloadText(svg, `CraneOps_TOP_${lv.id}.svg`, "image/svg+xml");
  }

  function exportTopDXF(){
    // Minimal R12-ish DXF: LINES + CIRCLES only (TOP view)
    const lv = getLevel();
    const cr = getCrane();
    const hk = getHook();

    function dxfHeader(){
      return [
        "0","SECTION","2","HEADER","9","$ACADVER","1","AC1009","0","ENDSEC",
        "0","SECTION","2","TABLES","0","ENDSEC",
        "0","SECTION","2","ENTITIES"
      ].join("\n") + "\n";
    }
    function dxfEnd(){ return ["0","ENDSEC","0","EOF"].join("\n"); }
    function line(x1,y1,x2,y2,layer="0"){
      return ["0","LINE","8",layer,"10",x1,"20",y1,"30",0,"11",x2,"21",y2,"31",0].join("\n") + "\n";
    }
    function circle(x,y,r,layer="0"){
      return ["0","CIRCLE","8",layer,"10",x,"20",y,"30",0,"40",r].join("\n") + "\n";
    }

    let dxf = dxfHeader();

    // bounds
    dxf += line(0,0, lv.bounds.w,0,"BORDER");
    dxf += line(lv.bounds.w,0, lv.bounds.w,lv.bounds.h,"BORDER");
    dxf += line(lv.bounds.w,lv.bounds.h, 0,lv.bounds.h,"BORDER");
    dxf += line(0,lv.bounds.h,0,0,"BORDER");

    // obstacles as rectangles
    lv.obstacles.forEach(o=>{
      const x1=o.x-o.w/2, x2=o.x+o.w/2, y1=o.y-o.h/2, y2=o.y+o.h/2;
      dxf += line(x1,y1,x2,y1,"NO_GO");
      dxf += line(x2,y1,x2,y2,"NO_GO");
      dxf += line(x2,y2,x1,y2,"NO_GO");
      dxf += line(x1,y2,x1,y1,"NO_GO");
    });

    // pick/set
    dxf += circle(lv.pick.x, lv.pick.y, 1.2, "PICK");
    dxf += circle(lv.set.x,  lv.set.y,  1.2, "SET");

    // crane + hook
    dxf += circle(crane.x, crane.y, 1.5, "CRANE");
    dxf += line(crane.x, crane.y, hk.x, hk.y, "RADIUS");
    dxf += circle(hk.x, hk.y, 0.9, "HOOK");

    dxf += dxfEnd();
    downloadText(dxf, `CraneOps_TOP_${lv.id}.dxf`, "application/dxf");
  }

  function downloadText(text, filename, mime){
    const blob = new Blob([text], {type: mime});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 2500);
  }

  $("btnExportSVG").onclick = exportTopSVG;
  $("btnExportDXF").onclick = exportTopDXF;

  // ---------- Pointer interactions (Plan mode CAD dragging + top view pan/zoom) ----------
  let vpCached = null;
  canvas.addEventListener("pointerdown", (e)=>{
    const layout = getLayout();
    vpCached = layout.top;
    const pt = {x:e.clientX, y:e.clientY};

    // Only interact with TOP view
    if(pt.x < vpCached.x || pt.x > vpCached.x+vpCached.w || pt.y < vpCached.y || pt.y > vpCached.y+vpCached.h) return;

    canvas.setPointerCapture(e.pointerId);

    const w = topPxToWorld(pt.x, pt.y, vpCached);

    if(state.mode === "PLAN"){
      const lv = getLevel();
      const hitCrane = dist(w.x,w.y, crane.x,crane.y) < 3.0;
      const hitPick  = dist(w.x,w.y, lv.pick.x,lv.pick.y) < 3.0;
      const hitSet   = dist(w.x,w.y, lv.set.x, lv.set.y) < 3.0;

      if(hitCrane){
        cam.dragging=true; cam.dragKind="crane";
        cam.dragOff.x = crane.x - w.x; cam.dragOff.y = crane.y - w.y;
      } else if(hitPick){
        cam.dragging=true; cam.dragKind="pick";
        cam.dragOff.x = lv.pick.x - w.x; cam.dragOff.y = lv.pick.y - w.y;
      } else if(hitSet){
        cam.dragging=true; cam.dragKind="set";
        cam.dragOff.x = lv.set.x - w.x; cam.dragOff.y = lv.set.y - w.y;
      } else {
        cam.dragging=true; cam.dragKind="pan";
        cam.dragOff.x = w.x; cam.dragOff.y = w.y;
      }
    } else {
      // In operate, allow panning
      cam.dragging=true; cam.dragKind="pan";
      const w0 = topPxToWorld(pt.x, pt.y, vpCached);
      cam.dragOff.x = w0.x; cam.dragOff.y = w0.y;
    }
  });

  canvas.addEventListener("pointermove", (e)=>{
    if(!cam.dragging || !vpCached) return;
    const layout = getLayout();
    const vp = layout.top;

    const w = topPxToWorld(e.clientX, e.clientY, vp);
    const lv = getLevel();

    if(cam.dragKind==="crane"){
      crane.x = clamp(w.x + cam.dragOff.x, 0, lv.bounds.w);
      crane.y = clamp(w.y + cam.dragOff.y, 0, lv.bounds.h);
    } else if(cam.dragKind==="pick"){
      lv.pick.x = clamp(w.x + cam.dragOff.x, 0, lv.bounds.w);
      lv.pick.y = clamp(w.y + cam.dragOff.y, 0, lv.bounds.h);
      if(!state.attached){ load.x=lv.pick.x; load.y=lv.pick.y; }
    } else if(cam.dragKind==="set"){
      lv.set.x = clamp(w.x + cam.dragOff.x, 0, lv.bounds.w);
      lv.set.y = clamp(w.y + cam.dragOff.y, 0, lv.bounds.h);
    } else if(cam.dragKind==="pan"){
      // keep the initial world point under cursor
      cam.x += (cam.dragOff.x - w.x);
      cam.y += (cam.dragOff.y - w.y);
    }
  });

  canvas.addEventListener("pointerup", (e)=> {
    cam.dragging=false; cam.dragKind=null; vpCached=null;
  });

  canvas.addEventListener("wheel",(e)=>{
    const layout = getLayout();
    const vp = layout.top;
    const mx=e.clientX, my=e.clientY;
    if(mx<vp.x||mx>vp.x+vp.w||my<vp.y||my>vp.y+vp.h) return;
    e.preventDefault();
    const before = topPxToWorld(mx,my,vp);
    const z = Math.exp(-e.deltaY * 0.0016);
    cam.zoom = clamp(cam.zoom * z, 2.0, 18.0);
    const after = topPxToWorld(mx,my,vp);
    cam.x += (before.x - after.x);
    cam.y += (before.y - after.y);
  }, {passive:false});

  // ---------- Simulation update ----------
  function step(dt){
    const lv = getLevel();
    const cr = getCrane();

    // Controls -> axes
    const prec = (state.precision || touch.precision) ? 0.35 : 1.0;
    const moveAxis = (
      (keys.has("KeyD")||keys.has("ArrowRight")? 1:0) -
      (keys.has("KeyA")||keys.has("ArrowLeft")? 1:0)
    ) + (isMobile()? touch.moveX : 0);

    const hoistAxis = (
      (keys.has("KeyS")||keys.has("ArrowDown")? 1:0) -
      (keys.has("KeyW")||keys.has("ArrowUp")? 1:0)
    ) + (isMobile()? touch.hoist : 0);

    const slewAxis = (
      (keys.has("KeyL")? 1:0) -
      (keys.has("KeyJ")? 1:0)
    ) + (isMobile()? touch.slew : 0);

    const luffAxis = (
      (keys.has("KeyI")? 1:0) -
      (keys.has("KeyK")? 1:0)
    ) + (isMobile()? touch.luff : 0);

    const telAxis = (
      (keys.has("KeyO")? 1:0) -
      (keys.has("KeyU")? 1:0)
    );

    if(state.mode==="OPERATE"){
      // Move base (simple along world X axis for game clarity)
      crane.x = clamp(crane.x + moveAxis * cr.move * prec * dt, 0, lv.bounds.w);

      // Slew
      crane.slew += slewAxis * cr.slew * prec * dt;
      crane.slew = (crane.slew + Math.PI*4) % (Math.PI*2);

      // Luff
      if(cr.type!=="TOWER"){
        crane.luff = clamp(crane.luff + luffAxis * cr.luff * prec * dt, deg2rad(15), deg2rad(82));
      } else {
        // Tower crane: use luffAxis to move trolley instead
        crane.trolley = clamp(crane.trolley + (-luffAxis) * 22 * prec * dt, 5, cr.boomMax);
      }

      // Telescope
      if(cr.type==="TEL"){
        crane.boomL = clamp(crane.boomL + telAxis * cr.tel * prec * 18 * dt, cr.boomMin, cr.boomMax);
      } else if(cr.type==="CRAWLER"){
        // allow "boom length" adjust slower
        crane.boomL = clamp(crane.boomL + telAxis * 10 * prec * dt, cr.boomMin, cr.boomMax);
      }

      // Hoist line length
      crane.hoist = clamp(crane.hoist + hoistAxis * cr.hoist * prec * dt * 10, 0.5, 75);
    }

    const hk = getHook();

    // Load behaviour
    if(state.attached){
      // springy pendulum-ish top view (stable, game friendly)
      const k = 12 * settings.swingMul;
      const d = 4.4;
      const ax = (hk.x - load.x) * k - load.vx * d;
      const ay = (hk.y - load.y) * k - load.vy * d;

      // wind gusts (SIM)
      if(settings.wind){
        const gust = (Math.sin(nowMs()*0.0013) + Math.sin(nowMs()*0.0021))*0.25;
        const wx = Math.cos(crane.slew + Math.PI/2) * gust;
        const wy = Math.sin(crane.slew + Math.PI/2) * gust;
        load.vx += wx * dt;
        load.vy += wy * dt;
      }

      load.vx += ax * dt;
      load.vy += ay * dt;
      load.x += load.vx * dt;
      load.y += load.vy * dt;

      // Keep within bounds softly
      if(load.x<0||load.x>lv.bounds.w) load.vx *= -0.4;
      if(load.y<0||load.y>lv.bounds.h) load.vy *= -0.4;
      load.x = clamp(load.x, 0, lv.bounds.w);
      load.y = clamp(load.y, 0, lv.bounds.h);

      // Height follows hook (minus tiny sling)
      load.z = Math.max(0, hk.z - 1.0);

      // Rotation tends to align with motion
      const speed = Math.hypot(load.vx, load.vy);
      const targetRot = Math.atan2(load.vy, load.vx);
      if(speed > 0.8){
        let diff = ((targetRot - load.rot + Math.PI*3)%(Math.PI*2)) - Math.PI;
        load.vr += diff * 3.0 * dt;
      }
      load.vr *= (1 - 2.6*dt);
      load.rot += load.vr * dt;
    } else {
      // on ground: settle at nearest stable (basic friction)
      load.z = 0;
      load.vx *= (1 - 6.0*dt);
      load.vy *= (1 - 6.0*dt);
    }

    // Collisions (top view footprint)
    const lw = lv.pick.w, lh = lv.pick.h;
    let collided = false;
    if(state.attached){
      for(const o of lv.obstacles){
        if(obbAabbCollide(load.x,load.y, lw,lh, load.rot, o.x,o.y,o.w,o.h)){
          collided = true; break;
        }
      }
      if(collided){
        state.collisions += 1;
        state.score = Math.max(0, state.score - 25);
        // bounce a bit
        load.vx *= -0.35;
        load.vy *= -0.35;
      }
    }

    // Score tick
    if(state.mode==="OPERATE"){
      state.score += dt * 2; // time alive
    }

    // Track peaks for rule scoring
    const r = hk.r;
    const cap = capAtRadiusT(cr, r);
    const util = (getLevel().pick.massT / cap);
    state._utilPeak = Math.max(state._utilPeak ?? 0, util);

    const swing = rad2deg(Math.atan2(Math.hypot(load.vx,load.vy), 9.81));
    state._swingPeak = Math.max(state._swingPeak ?? 0, swing);

    // UI updates
    updatePlanChecks();
    updateHudRuntime(util, swing, hk);
  }

  function updateHudRuntime(util, swingDeg, hk){
    const lv = getLevel();
    hud.util.textContent = `${Math.round(util*100)}%`;
    hud.swing.textContent = `${fmt(swingDeg,1)}°`;
    hud.h.textContent = `${fmt(hk.z,1)} m`;
    hud.r.textContent = `${fmt(hk.r,1)} m`;
    hud.zoom.textContent = `${fmt(cam.zoom,1)} px/m`;

    hud.barUtil.style.width = `${clamp(util*100, 0, 100)}%`;
    hud.barSwing.style.width = `${clamp(swingDeg / 25 * 100, 0, 100)}%`;
    hud.barH.style.width = `${clamp(hk.z / 60 * 100, 0, 100)}%`;
    hud.barR.style.width = `${clamp(hk.r / (getCrane().boomMax||80) * 100, 0, 100)}%`;

    // Hint guidance
    if(state.mode==="PLAN"){
      hud.hint.textContent = "PLAN: drag crane/pick/set in TOP. Open Plan Gate → tick minimum → Operate.";
    } else {
      hud.hint.textContent = state.attached
        ? "OPERATE: move + slew + luff/tele + hoist. Avoid red blocks. Set down at green set with hook low."
        : "OPERATE: get hook over magenta pick, hoist down near load, press SPACE (HOOK).";
    }

    // Warn in subtitle (clearance / utilisation)
    const clearOK = clearanceOK(hk.z);
    const warn = [];
    if(util > lv.rules.maxUtil) warn.push("UTIL high");
    if(swingDeg > lv.rules.maxSwingDeg) warn.push("swing high");
    if(!clearOK) warn.push("clearance low");
    $("subtitle").textContent = warn.length ? `Warnings: ${warn.join(" • ")}` : "Top (Plan) + Side (Elevation) • planning-gated gameplay";
  }

  // ---------- Rendering (CAD top + side) ----------
  function draw(){
    const layout = getLayout();
    ctx.clearRect(0,0,W,H);

    // background
    ctx.fillStyle = "rgba(11,18,32,1)";
    ctx.fillRect(0,0,W,H);

    drawViewport(layout.top, "TOP / PLAN", "MODELSPACE");
    drawViewport(layout.side, "SIDE / ELEVATION", "SECTION");

    drawTop(layout.top);
    drawSide(layout.side);

    requestAnimationFrame(draw);
  }

  function drawViewport(vp, title, sub){
    // frame
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.fillRect(vp.x, vp.y, vp.w, vp.h);

    ctx.strokeStyle = "rgba(255,255,255,.09)";
    ctx.lineWidth = 1;
    ctx.strokeRect(vp.x, vp.y, vp.w, vp.h);

    // title bar
    ctx.fillStyle = "rgba(15,22,33,.55)";
    ctx.fillRect(vp.x, vp.y, vp.w, 26);
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.beginPath(); ctx.moveTo(vp.x, vp.y+26); ctx.lineTo(vp.x+vp.w, vp.y+26); ctx.stroke();

    ctx.fillStyle = "rgba(233,238,247,.92)";
    ctx.font = `600 12px ${getComputedStyle(document.body).fontFamily}`;
    ctx.fillText(title, vp.x+10, vp.y+17);

    ctx.fillStyle = "rgba(159,176,199,.85)";
    ctx.font = `12px var(--mono)`;
    ctx.fillText(sub, vp.x+vp.w-10-ctx.measureText(sub).width, vp.y+17);

    ctx.restore();
  }

  function drawGridTop(vp){
    if(!settings.grid) return;
    const lv = getLevel();
    const step = 10; // metres
    ctx.save();
    ctx.beginPath();
    ctx.rect(vp.x, vp.y+26, vp.w, vp.h-26);
    ctx.clip();

    ctx.lineWidth = 1;
    for(let x=0;x<=lv.bounds.w;x+=step){
      const p1 = worldToTopPx(x,0,vp);
      const p2 = worldToTopPx(x,lv.bounds.h,vp);
      ctx.strokeStyle = (x%50===0) ? "rgba(42,58,82,.45)" : "rgba(20,34,56,.55)";
      ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
    }
    for(let y=0;y<=lv.bounds.h;y+=step){
      const p1 = worldToTopPx(0,y,vp);
      const p2 = worldToTopPx(lv.bounds.w,y,vp);
      ctx.strokeStyle = (y%50===0) ? "rgba(42,58,82,.45)" : "rgba(20,34,56,.55)";
      ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawTop(vp){
    const lv = getLevel();
    const cr = getCrane();
    const hk = getHook();

    ctx.save();
    ctx.beginPath();
    ctx.rect(vp.x, vp.y+26, vp.w, vp.h-26);
    ctx.clip();

    drawGridTop(vp);

    // Bounds box
    ctx.strokeStyle = "rgba(42,58,82,.8)";
    ctx.lineWidth = 2;
    const b0 = worldToTopPx(0,0,vp), b1=worldToTopPx(lv.bounds.w, lv.bounds.h, vp);
    ctx.strokeRect(Math.min(b0.x,b1.x), Math.min(b0.y,b1.y), Math.abs(b1.x-b0.x), Math.abs(b1.y-b0.y));

    // Obstacles
    for(const o of lv.obstacles){
      const p = worldToTopPx(o.x - o.w/2, o.y - o.h/2, vp);
      const q = worldToTopPx(o.x + o.w/2, o.y + o.h/2, vp);
      const rx = Math.min(p.x,q.x), ry = Math.min(p.y,q.y);
      const rw = Math.abs(q.x-p.x), rh = Math.abs(q.y-p.y);

      ctx.fillStyle = "rgba(255,77,109,.10)";
      ctx.fillRect(rx,ry,rw,rh);

      ctx.strokeStyle = "rgba(255,77,109,.9)";
      ctx.lineWidth = 2;
      ctx.strokeRect(rx,ry,rw,rh);

      ctx.fillStyle = "rgba(255,77,109,.9)";
      ctx.font = "12px var(--mono)";
      ctx.fillText(`${o.name} z=${o.z}m`, rx+6, ry+14);
    }

    // Pick / Set
    drawPoint(vp, lv.pick.x, lv.pick.y, "PICK", "var(--cadMag)");
    drawPoint(vp, lv.set.x, lv.set.y, "SET", "var(--cadGreen)");

    // Crane base
    const cb = worldToTopPx(crane.x, crane.y, vp);
    ctx.fillStyle = "rgba(51,246,255,.18)";
    ctx.beginPath(); ctx.arc(cb.x, cb.y, 12, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "rgba(51,246,255,.95)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cb.x, cb.y, 10, 0, Math.PI*2); ctx.stroke();

    // Slew axis crosshair
    ctx.strokeStyle = "rgba(51,246,255,.55)";
    ctx.beginPath(); ctx.moveTo(cb.x-16, cb.y); ctx.lineTo(cb.x+16, cb.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cb.x, cb.y-16); ctx.lineTo(cb.x, cb.y+16); ctx.stroke();

    // Radius line + hook
    const hp = worldToTopPx(hk.x,hk.y,vp);
    ctx.strokeStyle = "rgba(255,209,102,.95)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(cb.x,cb.y); ctx.lineTo(hp.x,hp.y); ctx.stroke();

    ctx.fillStyle = "rgba(255,209,102,.95)";
    ctx.beginPath(); ctx.arc(hp.x,hp.y, 5.5, 0, Math.PI*2); ctx.fill();

    // Load footprint
    const lw = lv.pick.w, lh = lv.pick.h;
    drawOBB(vp, load.x, load.y, lw, lh, load.rot, state.attached ? "rgba(233,238,247,.9)" : "rgba(233,238,247,.55)");

    // Hook-to-load “sling” line (top view)
    ctx.strokeStyle = "rgba(233,238,247,.35)";
    ctx.lineWidth = 1.5;
    const lp = worldToTopPx(load.x, load.y, vp);
    ctx.beginPath(); ctx.moveTo(hp.x, hp.y); ctx.lineTo(lp.x, lp.y); ctx.stroke();

    // Dimensions
    if(settings.dims){
      drawDimLine(vp, crane.x, crane.y, hk.x, hk.y, `R=${fmt(hk.r,1)}m`, "rgba(255,209,102,.95)");
    }

    // Model info
    ctx.fillStyle = "rgba(233,238,247,.88)";
    ctx.font = "12px var(--mono)";
    ctx.fillText(`${cr.brand} ${cr.model}  |  ${cr.type}  |  boom=${fmt(crane.boomL,1)}m  luff=${Math.round(rad2deg(crane.luff))}°`, vp.x+10, vp.y+vp.h-10);

    ctx.restore();
  }

  function drawPoint(vp, x,y, label, colorVar){
    const p = worldToTopPx(x,y,vp);
    ctx.fillStyle = `rgba(0,0,0,.35)`;
    ctx.beginPath(); ctx.arc(p.x,p.y, 10, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(p.x,p.y, 8, 0, Math.PI*2); ctx.stroke();
    ctx.fillStyle = ctx.strokeStyle;
    ctx.font = "12px var(--mono)";
    ctx.fillText(label, p.x+12, p.y-10);
  }

  function drawOBB(vp, cx,cy,w,h,theta, stroke){
    const p = worldToTopPx(cx,cy,vp);
    const s = cam.zoom;
    const ww = w*s, hh = h*s;

    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(theta);
    ctx.strokeStyle = stroke;
    ctx.fillStyle = "rgba(233,238,247,.06)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(-ww/2, -hh/2, ww, hh);
    ctx.fill(); ctx.stroke();
    // local axis tick
    ctx.strokeStyle = "rgba(233,238,247,.35)";
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(ww/2, 0); ctx.stroke();
    ctx.restore();
  }

  function drawDimLine(vp, x1,y1,x2,y2, text, color){
    const p1 = worldToTopPx(x1,y1,vp), p2=worldToTopPx(x2,y2,vp);
    // offset perpendicular
    const dx=p2.x-p1.x, dy=p2.y-p1.y;
    const l=Math.hypot(dx,dy)+1e-9;
    const nx=-dy/l, ny=dx/l;
    const off=14;
    const a={x:p1.x+nx*off, y:p1.y+ny*off};
    const b={x:p2.x+nx*off, y:p2.y+ny*off};

    ctx.save();
    ctx.strokeStyle = color; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();

    // end ticks
    ctx.beginPath(); ctx.moveTo(a.x-nx*6, a.y-ny*6); ctx.lineTo(a.x+nx*6, a.y+ny*6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(b.x-nx*6, b.y-ny*6); ctx.lineTo(b.x+nx*6, b.y+ny*6); ctx.stroke();

    // text
    ctx.fillStyle = color;
    ctx.font="12px var(--mono)";
    const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    ctx.fillText(text, mx+6, my-6);
    ctx.restore();
  }

  function drawSide(vp){
    const lv = getLevel();
    const cr = getCrane();
    const hk = getHook();

    // update side cam: keep base near left, focus z around hook
    sideCam.zoom = clamp(Math.min(vp.w, vp.h) / 65, 4.0, 10.0);
    sideCam.z = lerp(sideCam.z, Math.max(6, hk.z-6), 0.08);

    ctx.save();
    ctx.beginPath();
    ctx.rect(vp.x, vp.y+26, vp.w, vp.h-26);
    ctx.clip();

    // Grid
    if(settings.grid){
      for(let s=0;s<=140;s+=10){
        const p1 = sideToPx(s, -5, vp);
        const p2 = sideToPx(s, 90, vp);
        ctx.strokeStyle = (s%50===0) ? "rgba(42,58,82,.45)" : "rgba(20,34,56,.55)";
        ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
      }
      for(let z=0;z<=90;z+=10){
        const p1 = sideToPx(-5, z, vp);
        const p2 = sideToPx(160, z, vp);
        ctx.strokeStyle = (z%50===0) ? "rgba(42,58,82,.45)" : "rgba(20,34,56,.55)";
        ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
      }
    }

    // Ground line
    ctx.strokeStyle="rgba(233,238,247,.28)";
    ctx.lineWidth=2;
    const g1 = sideToPx(-5,0,vp), g2=sideToPx(160,0,vp);
    ctx.beginPath(); ctx.moveTo(g1.x,g1.y); ctx.lineTo(g2.x,g2.y); ctx.stroke();

    // Obstacles projected if they intersect the base->load ray
    const bx=crane.x, by=crane.y;
    const lx=load.x, ly=load.y;
    const dx=lx-bx, dy=ly-by;
    const segLen=Math.hypot(dx,dy)+1e-9;
    const ux=dx/segLen, uy=dy/segLen;

    // draw obstacles in side where ray crosses their footprint
    for(const o of lv.obstacles){
      // approximate: distance along ray to obstacle centre projection
      const vx=o.x-bx, vy=o.y-by;
      const s = vx*ux + vy*uy;
      // see if ray passes through AABB (rough check using closest point)
      const cx = bx + ux*s, cy = by + uy*s;
      const inside = (Math.abs(cx - o.x) <= o.w/2 + 0.5) && (Math.abs(cy - o.y) <= o.h/2 + 0.5);
      if(!inside) continue;

      const p = sideToPx(s - o.w/2, 0, vp);
      const q = sideToPx(s + o.w/2, o.z, vp);

      const rx=Math.min(p.x,q.x), ry=Math.min(p.y,q.y);
      const rw=Math.abs(q.x-p.x), rh=Math.abs(q.y-p.y);

      ctx.fillStyle="rgba(255,77,109,.10)";
      ctx.fillRect(rx,ry,rw,rh);
      ctx.strokeStyle="rgba(255,77,109,.9)";
      ctx.lineWidth=2;
      ctx.strokeRect(rx,ry,rw,rh);

      ctx.fillStyle="rgba(255,77,109,.9)";
      ctx.font="12px var(--mono)";
      ctx.fillText(`${o.name}`, rx+6, ry+14);
      ctx.fillText(`z=${o.z}m`, rx+6, ry+28);
    }

    // Crane (side)
    const baseP = sideToPx(0, cr.baseH, vp);
    ctx.fillStyle="rgba(51,246,255,.20)";
    ctx.beginPath(); ctx.arc(baseP.x, baseP.y, 8, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(51,246,255,.95)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(baseP.x, baseP.y, 6, 0, Math.PI*2); ctx.stroke();

    // Boom line + tip
    let tipS=hk.r;
    let tipZ;
    if(cr.type==="TOWER"){
      tipZ = cr.baseH + 38; // mast height (SIM)
      // jib line (horizontal)
      const jibP1 = sideToPx(0, tipZ, vp);
      const jibP2 = sideToPx(cr.boomMax, tipZ, vp);
      ctx.strokeStyle="rgba(255,209,102,.75)";
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(jibP1.x,jibP1.y); ctx.lineTo(jibP2.x,jibP2.y); ctx.stroke();

      // trolley
      const tr = sideToPx(hk.r, tipZ, vp);
      ctx.fillStyle="rgba(255,209,102,.95)";
      ctx.beginPath(); ctx.rect(tr.x-6, tr.y-6, 12, 12); ctx.fill();
    } else {
      // boom at luff angle
      const L = clamp(crane.boomL, cr.boomMin, cr.boomMax);
      const theta = crane.luff;
      tipS = L*Math.cos(theta);
      tipZ = cr.baseH + L*Math.sin(theta);
      const tipP = sideToPx(tipS, tipZ, vp);

      ctx.strokeStyle="rgba(255,209,102,.85)";
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(baseP.x, baseP.y); ctx.lineTo(tipP.x, tipP.y); ctx.stroke();

      ctx.fillStyle="rgba(255,209,102,.95)";
      ctx.beginPath(); ctx.arc(tipP.x, tipP.y, 5.5, 0, Math.PI*2); ctx.fill();
    }

    // Hook block + rope
    const hookP = sideToPx(hk.r, hk.z, vp);
    const tipP2 = sideToPx(tipS, tipZ, vp);

    ctx.strokeStyle="rgba(233,238,247,.55)";
    ctx.lineWidth=2;
    ctx.beginPath();
    // slight “cable curve”
    const mx = lerp(tipP2.x, hookP.x, 0.55);
    const my = lerp(tipP2.y, hookP.y, 0.55) + 8;
    ctx.moveTo(tipP2.x, tipP2.y);
    ctx.quadraticCurveTo(mx,my, hookP.x, hookP.y);
    ctx.stroke();

    // hook block
    ctx.fillStyle="rgba(233,238,247,.9)";
    ctx.beginPath(); ctx.roundRect(hookP.x-8, hookP.y-10, 16, 20, 4); ctx.fill();

    // Load (side)
    const loadH = Math.max(0, hk.z - 1.0);
    const loadP = sideToPx(hk.r, loadH, vp);
    ctx.fillStyle = "rgba(233,238,247,.08)";
    ctx.strokeStyle = "rgba(233,238,247,.75)";
    ctx.lineWidth = 2;
    const lw = lv.pick.w * 0.7;    // side silhouette
    const lh = lv.pick.h * 0.7;
    const wpx = lw * sideCam.zoom;
    const hpx = lh * sideCam.zoom;
    ctx.fillRect(loadP.x - wpx/2, loadP.y - hpx, wpx, hpx);
    ctx.strokeRect(loadP.x - wpx/2, loadP.y - hpx, wpx, hpx);

    // Clearance warning
    const clearOK = clearanceOK(hk.z);
    if(!clearOK){
      ctx.fillStyle="rgba(255,209,102,.95)";
      ctx.font="700 14px var(--mono)";
      ctx.fillText("CLEARANCE WARNING (SIM)", vp.x+12, vp.y+44);
    }

    // Side dims
    if(settings.dims){
      // radius dim
      ctx.strokeStyle="rgba(255,209,102,.7)";
      ctx.lineWidth=1.5;
      const p0=sideToPx(0, cr.baseH+0.5, vp);
      const p1=sideToPx(hk.r, cr.baseH+0.5, vp);
      ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
      ctx.fillStyle="rgba(255,209,102,.95)";
      ctx.font="12px var(--mono)";
      ctx.fillText(`R=${fmt(hk.r,1)}m`, (p0.x+p1.x)/2-18, p0.y-8);

      // height dim
      ctx.strokeStyle="rgba(51,246,255,.55)";
      const h0=sideToPx(hk.r+2, 0, vp);
      const h1=sideToPx(hk.r+2, hk.z, vp);
      ctx.beginPath(); ctx.moveTo(h0.x,h0.y); ctx.lineTo(h1.x,h1.y); ctx.stroke();
      ctx.fillStyle="rgba(51,246,255,.9)";
      ctx.fillText(`H=${fmt(hk.z,1)}m`, h1.x+6, (h0.y+h1.y)/2);
    }

    ctx.restore();
  }

  // roundRect polyfill (some browsers)
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }

  // ---------- Boot ----------
  buildHangar();
  buildLevels();
  resetToLevel(state.levelIndex);

  // Keep “Operate” button text reflecting mode
  setInterval(()=>{
    $("btnPlay").textContent = (state.mode==="OPERATE") ? "Operate" : "Operate";
  }, 500);

  // tick loop
  let last = nowMs();
  function tick(){
    const t = nowMs();
    const dt = clamp((t-last)/1000, 0, 0.05);
    last = t;
    step(dt);
    requestAnimationFrame(tick);
  }
  tick();
  draw();

  // Panel auto-close on click outside
  Object.values(overlays).forEach(ov => ov.addEventListener("click",(e)=>{
    if(e.target===ov) ov.classList.remove("on");
  }));

  // Persist plan gate and update status
  computePlanGate();
  updatePlanChecks();
  updateHud();
})();
</script>
</body>
</html>
